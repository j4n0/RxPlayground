
import RxSwift


exampleOf("Create observable sequences")
{
    _ = Observable.from([0,1,2,3,4,5])             // from array
    _ = Observable.from([1:"Hello",2:"World"])     // from dictionary
    _ = Observable.just("Hello Rx")                // from single element
    _ = Observable.of(1,2,3)                       // from variable list of elements
    _ = Observable<Int>.range(start: 1, count: 10) // from range of values
    _ = Observable<Void>.empty()                   // empty sequence. Sends one event: completed.
    _ = Observable<Any>.never()                    // sends no events (so it doesnâ€™t terminate)
    
    // sequence generated by a for-style iteration
    let o = Observable.generate(initialState: 0, condition: { $0 < 10 }, iterate: { $0 + 1 })
    o.subscribe { print($0) }           // print each element: 0 1 2 3 4 5 6 7 8 9
    o.toArray().subscribe { print($0) } // collect in an array and print it: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    // sequence that terminates immediately with error
    enum Cake: Error { case burnt }
    _ = Observable<Int>.error(Cake.burnt).subscribe { print($0) }
}


exampleOf("Different ways to write the subscribe method")
{
    let sequence = Observable.from([0.07])
    
    sequence.subscribe { event in
        switch event {
        case .next(let value):  print(value)
        case .error(let error): print(error)
        case .completed:        print("completed")
        }
    }
    
    sequence.subscribe { print($0) }
    
    sequence.subscribe({ (event: Event<Double>) in
        print(event)
    })
    
    sequence.subscribe(onNext: { element in
        print(element)
    }, onError: { error in
        print(error)
    }, onCompleted: {
        print("completed")
    }, onDisposed: {
        print("disposed")
    })
}


exampleOf("Cancel the subscription")
{
    // subscribe and cancel the subscription on deinit
    let bag = DisposeBag()
    _ = Observable.just("Hello")
        .subscribe (onNext:{ print($0) })
        .addDisposableTo(bag)
    
    // subscribe and cancel the subscription
    _ = Observable.just("Turtle")
        .subscribe { print($0) }
        .dispose()

}


exampleOf("Observable<type>.create")
{
    // creates an observable and specify the events it will fire
    let bag = DisposeBag()
    _ = Observable<String>.create { observer in
            observer.onNext("1")
            observer.onCompleted()
            return Disposables.create()
        }
        .subscribe { print($0) }
        .disposed(by: bag)
    
    // if you want to terminate with an error, create one: enum MyError: Error { case anError }
    // and send it: observer.onError(MyError.anError)
}

exampleOf("Observable<type>.create")
{
    // creates a factory of observables that returns a different one on each call
    let bag = DisposeBag()
    var flip = false
    let factory: Observable<Int> = Observable.deferred {
        flip = !flip
        return flip ? Observable.of(1,2,3) : Observable.of(4,5,6)
    }
    for _ in 0...3 {
        factory.subscribe { print($0) }.disposed(by: bag)
    }
}









